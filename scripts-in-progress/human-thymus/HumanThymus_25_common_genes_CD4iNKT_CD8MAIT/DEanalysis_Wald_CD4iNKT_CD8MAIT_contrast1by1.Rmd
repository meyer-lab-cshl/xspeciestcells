---
title: "Chapter X - R Notebook"
author: "Salom√© Carcy"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true

---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5,
                      warning=FALSE, message=FALSE,
                      root.dir = "~/Projects/phd/")
```


# IMPORT

## Import librairies
```{r import-librairies}
library(ggplot2)
library(RColorBrewer)
library(cowplot)
library(tidyverse)
library(dplyr)
library(Seurat)
library(SCpubr)
library(patchwork)
library(DESeq2)
library(pheatmap)

source("~/Projects/phd/scripts/colors_universal.R")
```

## Import data
```{r import-data}
seur_integrated <- readRDS("./data/clean_data/seurat_human_integrated_object_23_12_01.rds")
DimPlot(seur_integrated, reduction="umap_integrated", group.by="clusters_integrated_data", cols=cols_integrated)
```




# FUNCTIONS
- `aggregate.Matrix` and `dMcast` functions taken from `Matrix.utils` package (https://rdrr.io/cran/Matrix.utils/src/R/Matrix.utils.R)
- `runDeseq` function written in-house, inspired from tutorial : https://hbctraining.github.io/scRNA-seq/lessons/pseudobulk_DESeq2_scrnaseq.html
```{r define-functions}
aggregate.Matrix<-function(x,groupings=NULL,form=NULL,fun='sum'){
  if(!is(x,'Matrix')){
    x<-Matrix(as.matrix(x),sparse=TRUE)
  }
  if(fun=='count'){
    x<-x!=0
  }
  groupings2<-groupings
  if(!is(groupings2,'data.frame')){
    groupings2<-as(groupings2,'data.frame')
  }
  groupings2<-data.frame(lapply(groupings2,as.factor))
  groupings2<-data.frame(interaction(groupings2,sep = '_'))
  colnames(groupings2)<-'A'
  if(is.null(form)){
    form<-as.formula('~0+.')
  }
  form<-as.formula(form)
  mapping<-dMcast(groupings2,form)
  colnames(mapping)<-substring(colnames(mapping),2)
  result<-t(mapping) %*% x
  if(fun=='mean'){
    result@x<-result@x/(aggregate.Matrix(x,groupings2,fun='count'))@x
  }
  attr(result,'crosswalk')<-grr::extract(groupings,match(rownames(result),groupings2$A))
  return(result)
}


dMcast<-function(data,formula,fun.aggregate='sum',value.var=NULL,as.factors=FALSE,factor.nas=TRUE,drop.unused.levels=TRUE){
  values<-1
  if(!is.null(value.var)){
    values<-data[,value.var]
    }
  alltms<-terms(formula,data=data)
  response<-rownames(attr(alltms,'factors'))[attr(alltms,'response')]
  tm<-attr(alltms,"term.labels")
  interactionsIndex<-grep(':',tm)
  interactions<-tm[interactionsIndex]
  simple<-setdiff(tm,interactions)
  i2<-strsplit(interactions,':')
  newterms<-unlist(lapply(i2,function (x) paste("paste(",paste(x,collapse=','),",","sep='_'",")")))
  newterms<-c(simple,newterms)
  newformula<-as.formula(paste('~0+',paste(newterms,collapse='+')))
  allvars<-all.vars(alltms)
  data<-data[,c(allvars),drop=FALSE]
  if(as.factors){
    data<-data.frame(lapply(data,as.factor))
    }
  characters<-unlist(lapply(data,is.character))
  data[,characters]<-lapply(data[,characters,drop=FALSE],as.factor)
  factors<-unlist(lapply(data,is.factor))
  #Prevents errors with 1 or fewer distinct levels
  data[,factors]<-lapply(data[,factors,drop=FALSE],function (x) 
  {
    if(factor.nas)
      if(any(is.na(x)))
      {
        levels(x)<-c(levels(x),'NA')
        x[is.na(x)]<-'NA'
      }
    if(drop.unused.levels)
        if(nlevels(x)!=length(na.omit(unique(x))))
          x<-factor(as.character(x))
    y<-contrasts(x,contrasts=FALSE,sparse=TRUE)
    attr(x,'contrasts')<-y
    return(x)
  })
  #Allows NAs to pass
  attr(data,'na.action')<-na.pass
  result<-Matrix::sparse.model.matrix(newformula,data,drop.unused.levels = FALSE,row.names=FALSE)
  brokenNames<-grep('paste(',colnames(result),fixed = TRUE)
  colnames(result)[brokenNames]<-lapply(colnames(result)[brokenNames],function (x) {
    x<-gsub('paste(',replacement='',x=x,fixed = TRUE) 
    x<-gsub(pattern=', ',replacement='_',x=x,fixed=TRUE) 
    x<-gsub(pattern='_sep = \"_\")',replacement='',x=x,fixed=TRUE)
    return(x)
  })

  result<-result*values
  if(isTRUE(response>0))
  {
    responses=all.vars(terms(as.formula(paste(response,'~0'))))
    result<-aggregate.Matrix(result,data[,responses,drop=FALSE],fun=fun.aggregate)
  }
  return(result)
}


prep_data_for_deseq <- function(
    counts_matrix,
    groups_df
  ){
    ## ****************
  ## AGGREGATE COUNTS
  cat("\n--Aggregating counts--\n")
  count.agg <- t(counts_matrix[, which(colnames(counts_matrix) %in% rownames(groups_df))])
  nrow(groups_df) == nrow(count.agg) # verify nb of cells in "groups" (rows) is same nb of cells in "count.agg" (rows)
  
  # Aggregate counts based on columns in "groups"
  count.agg <- aggregate.Matrix(count.agg, groupings = groups_df, fun = "sum")
  
  # Sanity checks
  cat("\nDimensions aggregated matrix:", dim(count.agg))
  cat("\nPreview aggregated matrix:")
  print(count.agg[, 1:6])
  # table(colSums(count.agg) == 0) # check if any gene has total count of 0
  
  # Final counts for DESeq (groups as columns, genes as rows)
  counts.deseq <- data.frame(t(count.agg))
  counts.deseq <- counts.deseq[rowSums(counts.deseq)!=0,] # remove genes that have total count of 0
  
  
  ## ****************
  ## PREPARE METADATA DF FOR DESEQ
  cat("\n--Preparing metadata--\n")
  # Have metadata df where rownames are the colnames of "counts.deseq" (the groups)
  metadf.deseq <- groups_df %>%
    distinct() %>%
    unite(sample_id, remove=FALSE)
  rownames(metadf.deseq) <- metadf.deseq$sample_id
  
  # Check that the row names of metadf.deseq are the same as the column names of counts.deseq in order to use as input to DESeq2
  metadf.deseq <- metadf.deseq[match(colnames(counts.deseq), rownames(metadf.deseq)),] # reorder rows in metadf.deseq to match order of columns in counts.deseq
  all(rownames(metadf.deseq) == colnames(counts.deseq))
  cat("\nPreview metadf for Deseq2:")
  print(metadf.deseq)
  
  return(list(
    "counts_deseq"=counts.deseq,
    "metadf_deseq"=metadf.deseq
  ))
}


runDeseq <- function(data_deseq) {
    
  # ## ****************
  # ## AGGREGATE COUNTS
  # cat("\n--Aggregating counts--\n")
  # count.agg <- t(counts_matrix[, which(colnames(counts_matrix) %in% rownames(groups_df))])
  # nrow(groups_df) == nrow(count.agg) # verify nb of cells in "groups" (rows) is same nb of cells in "count.agg" (rows)
  # 
  # # Aggregate counts based on columns in "groups"
  # count.agg <- aggregate.Matrix(count.agg, groupings = groups_df, fun = "sum")
  # 
  # # Sanity checks
  # cat("\nDimensions aggregated matrix:", dim(count.agg))
  # cat("\nPreview aggregated matrix:")
  # print(count.agg[, 1:6])
  # # table(colSums(count.agg) == 0) # check if any gene has total count of 0
  # 
  # # Final counts for DESeq (groups as columns, genes as rows)
  # counts.deseq <- data.frame(t(count.agg))
  # counts.deseq <- counts.deseq[rowSums(counts.deseq)!=0,] # remove genes that have total count of 0
  # 
  # 
  # ## ****************
  # ## PREPARE METADATA DF FOR DESEQ
  # cat("\n--Preparing metadata--\n")
  # # Have metadata df where rownames are the colnames of "counts.deseq" (the groups)
  # metadf.deseq <- groups_df %>%
  #   distinct() %>%
  #   unite(sample_id, remove=FALSE)
  # rownames(metadf.deseq) <- metadf.deseq$sample_id
  # 
  # # Check that the row names of metadf.deseq are the same as the column names of counts.deseq in order to use as input to DESeq2
  # metadf.deseq <- metadf.deseq[match(colnames(counts.deseq), rownames(metadf.deseq)),] # reorder rows in metadf.deseq to match order of columns in counts.deseq
  # all(rownames(metadf.deseq) == colnames(counts.deseq))
  # cat("\nPreview metadf for Deseq2:")
  # print(metadf.deseq)
  
  
  ## ****************
  # BATCH CORRECT COUNTS
  cat("\n--Create DESeq2 object with design [donor_id + lineage_id]--\n")
  counts.deseq <- data_deseq$counts_deseq
  metadf.deseq <- data_deseq$metadf_deseq
  dds <- DESeqDataSetFromMatrix(counts.deseq,
                                colData = metadf.deseq,
                                design = ~ donor_id + lineage_id)

  # # Transform counts for data visualization
  # cat("\n--Batch correct counts--\n")
  # rld <- rlog(dds, blind=TRUE)
  # # Sanity check
  # head(assay(rld))
  # 
  # # Plot PCA
  # # DESeq2::plotPCA(rld, intgroup = "sample_id")
  # # DESeq2::plotPCA(rld, intgroup = "donor_id")
  # # DESeq2::plotPCA(rld, intgroup = "lineage_id")
  # 
  # # Correct for batch effect, and then run PCA
  # counts_corrected <- limma::removeBatchEffect(x=assay(rld),
  #                                              batch=metadf.deseq$donor_id,
  #                                              design=model.matrix(~ lineage_id, metadf.deseq))
  # rv <- matrixStats::rowVars(counts_corrected) # variance of each gene
  # select_rv <- order(rv, decreasing = TRUE)[seq_len(500)] # get the positions of the top 500 most variable genes?...
  # pca <- prcomp(t(counts_corrected[select_rv,])) # run pca on top 500 HVG
  # percentVar <- pca$sdev^2/sum(pca$sdev^2)
  # counts_pca <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2],
  #                          donor = metadf.deseq$donor_id,
  #                          condition = metadf.deseq$lineage_id) # MODIFY "condition" BASED ON WHAT YOU ARE COMPARING
  # # Plot
  # ggplot(counts_pca, aes(x = PC1, y = PC2, color = condition, shape=donor)) +
  #   geom_point(size = 4) +
  #   xlab(paste0("PC1: ", round(percentVar[1] * 100), "% variance")) +
  #   ylab(paste0("PC2: ", round(percentVar[2] * 100), "% variance")) +
  #   coord_fixed(expand=TRUE) +
  #   scale_y_continuous(expand = c(0.1,0.1))+
  #   ggtitle("limma without design formula")
  # 
  # 
  # # Compute pairwise correlation values on the batch-effect-corrected matrix
  # rld_cor <- cor(counts_corrected[select_rv,])
  # # Plot heatmap
  # pheatmap(rld_cor, annotation = metadf.deseq[, c("lineage_id"), drop=F])
  
  
  ## ****************
  # RUN DESEQ2
  cat("\n--Run DESeq2--\n")

  dds <- DESeq(dds)
  # plotDispEsts(dds)
  return(dds)
  }



runContrast <- function(
    deseq_object=dds,
    contrast_vector,
    genes_sanitycheck = c("RUNX3", "ZBTB7B", "ZBTB16"),
    padj_thresh = 0.01,
    remove_ribo_degenes = T){
  # Output results of Wald test for contrast
  # contrast <- c("lineage_id", "CD4", "iNKT") # MODIFY BASED ON WHAT YOU ARE COMPARING
  res <- results(deseq_object,
                 contrast = contrast_vector,
                 alpha = 0.05)
  res <- lfcShrink(deseq_object,
                   type="ashr",
                   contrast = contrast_vector,
                   res=res)
  print(res[genes_sanitycheck,])

  # Get df with only significant genes
  result.df <- res %>%
    data.frame() %>%
    rownames_to_column(var="gene") %>%
    as_tibble() %>%
    filter(padj < padj_thresh) %>%
    arrange(padj)
  
  if(remove_ribo_degenes==T){result.df <- result.df %>% filter(!gene %in% grep("RPL|RPS", gene, value=T))}
  
  # return
  return(list(
   # "counts_corrected"=counts_corrected,
   # "rld_object"=rld,
   "degenes"=result.df,
   "allgenes"=res
  ))
}
```





# RUN DESEq2 ONE-BY-ONE CONTRAST

## Run DESeq by contrasting one by one
Here we will keep only alpha beta lineages that are in clusters 3,9,10,11 (the "naive" CCR9- and CCR7-expressing clusters, not the agonists).
```{r run-deseq2}
groups_df <- seur_integrated@meta.data[,c("tissue", "tcell_lineage", "donor_id", "clusters_integrated_data")] %>%
  filter(tissue == "Thymus" & tcell_lineage %in% c("CD4", "iNKT", "CD8", "MAIT") & donor_id %in% 2:4) %>%
  # keep only non-memory clusters
  # filter(clusters_integrated_data %in% c(2:5, 7:11)) %>%
  filter(clusters_integrated_data %in% c(3,11,9,10)) %>%
  # create new column that's CD4NKT or CD8MAIT
  mutate(donor_id=paste0("donor", donor_id)) %>%
  mutate(lineage_id=tcell_lineage)
groups_df_for_deseq <- groups_df %>%
  select(lineage_id, donor_id)

# Prep data for DESeq
deseq_data <- prep_data_for_deseq(
  counts_matrix=seur_integrated@assays$RNA@counts,
  groups_df=groups_df_for_deseq
  )

# RUN DESEq2
dds <- DESeqDataSetFromMatrix(deseq_data$counts_deseq,
                              colData = deseq_data$metadf_deseq,
                              design = ~ donor_id + lineage_id)
dds <- DESeq(dds)
plotDispEsts(dds)
```


## Get the DE genes for each contrast
We will run DE analysis between:
- CD4vsCD8
- CD4vsMAIT
- iNKTvsCD8
- iNKTvsMAIT

Then as a negative control, we will run DE analysis between:
- CD4vsCD8
- CD4vsiNKT
- MAITvsCD8
- MAITvsiNKT

Overall, the contrasts we need are:
- CD4vsCD8, CD4vsMAIT, CD4vsiNKT
- iNKTvsCD8, iNKTvsMAIT
- MAITvsCD8

```{r contrast-1by1}
# Get all the contrasts to run
combinations_contrast <- combn(c("CD4", "CD8", "iNKT", "MAIT"), 2)

listDE_final <- list()
for(i in 1:ncol(combinations_contrast)){
  lineage1 <- combinations_contrast[1,i]
  lineage2 <- combinations_contrast[2,i]
  contrast_name <- paste0(lineage1, "vs", lineage2)
  cat("\n", contrast_name, "\n")
  
  # get DE genes from contrast
  deseq_output_temp <- NULL
  deseq_output_temp <- runContrast(contrast_vector = c("lineage_id", lineage1, lineage2), padj_thresh = 0.05)
  listDE_final[[contrast_name]] <- deseq_output_temp$degenes
}


names(listDE_final)

# some sanity checks
listDE_final$CD4vsCD8 %>%
  filter(gene %in% c("RUNX3", "LINC02446", "ZBTB7B", "CD40LG"))


# Get the CD4/iNKT vs CD8/MAIT DE genes
cd4_inkt_up <- intersect(
  intersect(
    listDE_final$CD4vsCD8 %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$CD8vsiNKT %>% filter(log2FoldChange<0) %>% pull(gene) # we want genes that are upregulated in iNKTvsCD8
  ),
  intersect(
    listDE_final$CD4vsMAIT %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$iNKTvsMAIT %>% filter(log2FoldChange>0) %>% pull(gene)
  ))

cd8_mait_up <- intersect(
  intersect(
    listDE_final$CD4vsCD8 %>% filter(log2FoldChange<0) %>% pull(gene),
    listDE_final$CD8vsiNKT %>% filter(log2FoldChange>0) %>% pull(gene)
  ),
  intersect(
    listDE_final$CD4vsMAIT %>% filter(log2FoldChange<0) %>% pull(gene),
    listDE_final$iNKTvsMAIT %>% filter(log2FoldChange<0) %>% pull(gene)
  ))

DEgenes_to_plot <- c(cd4_inkt_up, cd8_mait_up)


# now get the genes for negative control, in CD4/MAIT vs CD8/iNKT
# Get the CD4/iNKT vs CD8/MAIT DE genes
cd4_mait_up <- intersect(
  intersect( # CD4/MAIT vs CD8
    listDE_final$CD4vsCD8 %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$CD8vsMAIT %>% filter(log2FoldChange<0) %>% pull(gene) # we want genes that are upregulated in MAITvsCD8
  ),
  intersect( # CD4/MAIT vs iNKT
    listDE_final$CD4vsiNKT %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$iNKTvsMAIT %>% filter(log2FoldChange<0) %>% pull(gene) # we want genes that are up in iNKTvsMAIT
  ))

cd8_inkt_up <- intersect(
  intersect( # CD8/iNKT vs CD4
    listDE_final$CD4vsCD8 %>% filter(log2FoldChange<0) %>% pull(gene),
    listDE_final$CD8vsiNKT %>% filter(log2FoldChange<0) %>% pull(gene)
  ),
  intersect( # CD8/iNKT vs MAIT
    listDE_final$CD8vsMAIT %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$iNKTvsMAIT %>% filter(log2FoldChange>0) %>% pull(gene)
  ))

DEgenes_to_plot_negcontrol <- c(cd4_mait_up, cd8_inkt_up)
```



## Batch correct counts
```{r batch-correct-counts-per-lineage}
# Transform counts for data visualization
rld_for_batchcorrect <- rlog(dds, blind=TRUE)
# Sanity check
head(assay(rld_for_batchcorrect))

# Correct for batch effect, and then run PCA
counts_corrected <- limma::removeBatchEffect(x=assay(rld_for_batchcorrect),
                                             batch=deseq_data$metadf_deseq$donor_id,
                                             design=model.matrix(~ lineage_id, deseq_data$metadf_deseq))
rv <- matrixStats::rowVars(counts_corrected) # variance of each gene
select_rv <- order(rv, decreasing = TRUE)[seq_len(500)] # get the positions of the top 500 most variable genes?...
pca <- prcomp(t(counts_corrected[select_rv,])) # run pca on top 500 HVG
percentVar <- pca$sdev^2/sum(pca$sdev^2)
counts_pca <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2],
                         donor = deseq_data$metadf_deseq$donor_id,
                         condition = deseq_data$metadf_deseq$lineage_id) # MODIFY "condition" BASED ON WHAT YOU ARE COMPARING
# Plot
ggplot(counts_pca, aes(x = PC1, y = PC2, color = condition, shape=donor)) +
  geom_point(size = 4) +
  xlab(paste0("PC1: ", round(percentVar[1] * 100), "% variance")) +
  ylab(paste0("PC2: ", round(percentVar[2] * 100), "% variance")) +
  coord_fixed(expand=TRUE) +
  scale_y_continuous(expand = c(0.1,0.1))+
  ggtitle("limma without design formula")


# Compute pairwise correlation values on the batch-effect-corrected matrix
rld_cor <- cor(counts_corrected[select_rv,])
# Plot heatmap
pheatmap(rld_cor, annotation = deseq_data$metadf_deseq[, c("lineage_id"), drop=F])
```


## Plot heatmap
```{r plot-deseq, fig.width=5, fig.height=10}
# PLOT (per lineage)
counts_corrected_to_plot <- counts_corrected[c(DEgenes_to_plot, "EPHB6"),]
# counts_corrected_to_plot <- counts_corrected_to_plot[,c(paste0("CD4_donor", 2:4), paste0("iNKT_donor", 2:4), paste0("CD8_donor", 2:4), paste0("MAIT_donor", 2:4))]

# colors for donor
cols_donorid <- c("lightgrey", "darkgrey", "#737373")
names(cols_donorid) <- unique(deseq_data$metadf_deseq$donor_id)

# pdf("./scripts-in-progress/human-thymus/HumanThymus_25_common_genes_CD4iNKT_CD8MAIT/plots/heatmap_DEgenes_CD4iNKT_vs_CD8MAIT_contrast1by1.pdf",
#     width=5, height=10)
pheatmap(
  counts_corrected_to_plot,
  color = rev(colorRampPalette(brewer.pal(10, "RdBu"))(100)),
  scale = "row", # z-score
  cluster_rows = T,
  cluster_cols = T,
  border_color = NA,
  # Create gaps to separate CD4/NKT
  # gaps_row=c(2,6, 11, 14),
  cutree_rows = 3,
  annotation_col = deseq_data$metadf_deseq %>% dplyr::select(c(lineage_id, donor_id)),
  annotation_colors = list(
    lineage_id = cols_lineages,
    donor_id=cols_donorid
  ),
  # Change rows text format
  show_rownames = T,
  fontsize_row = 4,
  # Change columns
  angle_col=45,
  fontsize_col = 4,
  # title
  main="CD4/iNKT vs CD8/MAIT one by one contrast intersect DE genes (c3, c9, c10, c11)"
)
# dev.off()
```


## Plot DE genes Tinn vs Tconv

```{r}
# now get the genes for Tinn vs Tconv, in CD4/CD8 vs iNKT/MAIT
cd4_cd8_up <- intersect(
  intersect( # CD4/CD8 vs iNKT
    listDE_final$CD4vsiNKT %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$CD8vsiNKT %>% filter(log2FoldChange>0) %>% pull(gene)
  ),
  intersect( # CD4/CD8 vs MAIT
    listDE_final$CD4vsMAIT %>% filter(log2FoldChange>0) %>% pull(gene),
    listDE_final$CD8vsMAIT %>% filter(log2FoldChange>0) %>% pull(gene)
  ))

inkt_mait_up <- intersect(
  intersect( # iNKT/MAIT vs CD4
    listDE_final$CD4vsiNKT %>% filter(log2FoldChange<0) %>% pull(gene),
    listDE_final$CD4vsMAIT %>% filter(log2FoldChange<0) %>% pull(gene)
  ),
  intersect( # iNKT/MAIT vs CD8
    listDE_final$CD8vsiNKT %>% filter(log2FoldChange<0) %>% pull(gene),
    listDE_final$CD8vsMAIT %>% filter(log2FoldChange<0) %>% pull(gene)
  ))

DEgenes_to_plot_tinn_tconv <- c(cd4_cd8_up, inkt_mait_up)


# PLOT (per lineage)
counts_corrected_to_plot_tconv_tinn <- counts_corrected[DEgenes_to_plot_tinn_tconv,]

# pdf("./scripts-in-progress/human-thymus/HumanThymus_25_common_genes_CD4iNKT_CD8MAIT/plots/heatmap_DEgenes_CD4CD8_vs_iNKTMAIT_contrast1bypadj0_05.pdf",
#     width=7, height=5)
pheatmap(
  counts_corrected_to_plot_tconv_tinn,
  color = rev(colorRampPalette(brewer.pal(10, "RdBu"))(100)),
  scale = "row", # z-score
  cluster_rows = T,
  cluster_cols = T,
  border_color = NA,
  # Create gaps to separate CD4/NKT
  # gaps_row=c(2,6, 11, 14),
  cutree_rows = 2,
  annotation_col = deseq_data$metadf_deseq %>% dplyr::select(c(lineage_id, donor_id)),
  annotation_colors = list(
    lineage_id = cols_lineages,
    donor_id=cols_donorid
  ),
  # Change rows text format
  show_rownames = T,
  fontsize_row = 4,
  # Change columns
  angle_col=45,
  fontsize_col = 4,
  # title
  main="CD4/CD8 vs iNKT/MAIT one by one contrast\nintersect DE genes (c3, c9, c10, c11)\npadj<0.05"
)
# dev.off()
```





# SESSION INFO
```{r}
sessionInfo()
```


