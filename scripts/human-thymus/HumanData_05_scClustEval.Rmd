---
title: "Human data - evaluate clusters based on k.param, # PCs and resolution"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---

```{r, include=FALSE}
knitr::opts_chunk$set(root.dir = "~/Projects/20220809_Thymic-iNKT-CrossSpecies/scripts/human-thymus/")
```


## 1. Import

```{r import-librairies, message=FALSE}
# Libraries
library(ggplot2)
library(cowplot)
library(Seurat)
library(SeuratWrappers)
library(harmony)
library(tidyverse)
library(scclusteval)
```




## 2. Trying scClustEval on 5k PBMC data

Take a quick look at the PBMC 5k data
```{r}
# Import data
pbmc <- readRDS("../../data/07_scClustEval/pbmc/pbmc_5k_v3_label_transfered_from_10k.rds")
subsample_idents<- readRDS("../../data/07_scClustEval/pbmc/output_snakemake/gather_subsample.rds")
fullsample_idents<- readRDS("../../data/07_scClustEval/pbmc/output_snakemake/gather_full_sample.rds")

# pbmc@meta.data
# DimPlot(pbmc)
```

Explore full dataset

```{r}
## how many PCs to include
ElbowPlot(pbmc, ndims = 40)

# a tibble with a list column
fullsample_idents
# fullsample_idents[1,]$original_ident_full[[1]] # original_ident_full is the vector of cells with the cluster number they are assigned to.

## how many clusters for each different comibination of parameter set?
fullsample_idents %>%
  mutate(cluster_number = purrr::map_dbl(original_ident_full, ~length(unique(.x))))

###_________________________________________
# HEATMAPS
# what's the relationship of clusters between k_param 8, 20, 100, with same pc=20 and resolution = 0.6

# Get the row numbers
fullsample_idents %>% mutate(id = row_number()) %>%
  filter(pc == 20, resolution == 0.6, k_param %in% c(8, 20, 100))

## x-axis is k_param = 20, and y-axis is k_param = 8
PairWiseJaccardSetsHeatmap(fullsample_idents$original_ident_full[[2]],
                           fullsample_idents$original_ident_full[[11]],
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = T, cluster_column =T)

## x-axis is k_param = 100, and y-axis is k_param = 8
PairWiseJaccardSetsHeatmap(fullsample_idents$original_ident_full[[2]],
                           fullsample_idents$original_ident_full[[29]],
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = T, cluster_column =T)

# The k.param in the k-nearest neighbor algorithm after which a SNN graph is constructed. This parameter determines the resolution of the clustering where a bigger k yields a more interconnected graph and bigger clusters. We see if we increase the k param to 100, we get fewer number of total number of clusters.

###_________________________________________
# DIMENSION REDUCTION
# Letâ€™s check how the clusters are splitting when we increase the k.param.
k8_ident <- fullsample_idents %>%
  filter(pc == 20, resolution == 0.6, k_param == 8)  %>%
  pull(original_ident_full) %>%
  `[[`(1)
pbmc <- AddMetaData(pbmc, metadata = k8_ident, col.name = "res0.6_k8")

k100_ident <- fullsample_idents %>%
  filter(pc == 20, resolution == 0.6, k_param == 100)  %>%
  pull(original_ident_full) %>%
  `[[`(1)
pbmc <- AddMetaData(pbmc, metadata = k100_ident, col.name = "res0.6_k100")

DimPlot(pbmc, reduction = "umap", label = TRUE, group.by = "res0.6_k8", repel = TRUE) + ggtitle("k_param 8") + NoLegend() |
  DimPlot(pbmc, reduction = "umap", label = TRUE, group.by = "res0.6_k100", repel = TRUE) + ggtitle("k_param 100") + NoLegend()

# Check the clusters vs the predicted cell types at k = 8
PairWiseJaccardSetsHeatmap(set_names(pbmc@meta.data$res0.6_k8, nm=colnames(pbmc)),
                           set_names(pbmc@meta.data$predicted.id, nm=colnames(pbmc)),
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = F, cluster_column =F)
PairWiseJaccardSetsHeatmap(set_names(pbmc@meta.data$res0.6_k100, nm=colnames(pbmc)),
                           set_names(pbmc@meta.data$predicted.id, nm=colnames(pbmc)),
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = F, cluster_column =F)
# when the k_param is big (100), many cell types are merged together.


###_________________________________________
# SILHOUETTE PLOTS
## change idents to cluster id when k is 8
Idents(pbmc)<- pbmc@meta.data$res0.6_k8
silhouette_scores<- CalculateSilhouette(pbmc, dims = 1:20)
sil_p1<- SilhouetteRainCloudPlot(silhouette_scores) + ggtitle("k_param 8")

## check silhouette score when k is 100
Idents(pbmc)<- pbmc@meta.data$res0.6_k100
silhouette_scores<- CalculateSilhouette(pbmc, dims = 1:20)
sil_p2<- SilhouetteRainCloudPlot(silhouette_scores) + ggtitle("k_param 100")

sil_p1 / sil_p2

# cluster 5 (k=100) split into clusters 7 and 12 (k=8)
# silhouette width for cluster 5 (k=100) is higher than clusters 7 and 12 (k=8), suggesting that k=100 is a better option?
```




## 3. scClustEval on thymic iNKT cells

```{r import-data-inkt}
# Import data
thym.nkt <- readRDS("../../data/07_scClustEval/input/nkt_object_22-11-10.rds")
subsample_idents  <- readRDS("../../data/07_scClustEval/thymic_nkt/gather_subsample.rds")
fullsample_idents <- readRDS("../../data/07_scClustEval/thymic_nkt/gather_full_sample.rds")


# Take quick peek at the data
# thym.nkt
# thym.nkt@meta.data
DimPlot(thym.nkt)
```


### 3.1. Preprocess NKT data

We will need a visualization of the NKT cells preprocessed separately (and not based on all T cells).

```{r nkt-preprocessing}
# Create new seurat object with only genes expressed in >20 cells
initseurat <- CreateSeuratObject(counts = GetAssayData(object = thym.nkt, slot = "counts", assay="RNA"),
                                 meta.data = thym.nkt@meta.data,
                                 min.cells=20)
# print(initseurat) # sanity check

# Normalize with SCTransform (without splitting object)
seur.SCT <- SCTransform(initseurat,
                        assay="RNA",
                        new.assay.name="SCT",
                        vars.to.regress = 'percent.mt',
                        seed.use = 1448145,
                        verbose=F)
  
# Run PCA (don't scale data when using SCTransform)
seur.SCT <- RunPCA(object = seur.SCT, assay = "SCT", npcs = 50, seed.use=42, verbose=F)
p1 <- DimPlot(seur.SCT, reduction = "pca", group.by = "orig.ident") + ggtitle("PCA pre-integration")
# ElbowPlot(seur.SCT)
# print(seur.SCT) # sanity check
  
  # Run Harmony for integration
seur.harmony <- RunHarmony(object = seur.SCT,
                           assay.use = "SCT",
                           reduction = "pca",
                           dims.use = 1:50,
                           max.iter.harmony=30,
                           group.by.vars = c("Sex", "Method"),
                           plot_convergence = F)
p2 <- DimPlot(seur.harmony, reduction = "harmony", group.by = "orig.ident") + ggtitle("PCA post-integration")
print(p1 | p2)

# Run UMAP
seur.harmony <- RunUMAP(object = seur.harmony, dims = 1:15, assay = "SCT", reduction = "harmony", verbose=F, seed.use=42)
# seur.harmony <- FindNeighbors(object = seur.harmony, dims = 1:10, assay = "SCT", reduction = "harmony", verbose=F) %>%
#     FindClusters(resolution = res, verbose=F, random.seed=42)

DimPlot(seur.harmony)
```



### 3.2. Explore different parameters on NKT dataset

```{r nkt-full-data, width=15}
#___________________________
# DEFINE FUNCTION
paramUMAP <- function(seuratobject, pc_nb=c(15,15,15), res=c(0.7, 0.7, 0.7), knn=c(20,20,20)){
  # Plot1
  cat("Set1:", pc_nb[1], res[1], knn[1], "\n")
  ident1 <- fullsample_idents %>%
    dplyr::filter(pc == pc_nb[1], resolution == res[1], k_param == knn[1])  %>%
    pull(original_ident_full) %>%
    `[[`(1)
  seuratobject <- AddMetaData(seuratobject, metadata = ident1, col.name = "set1")

  # Plot2
  cat("Set2:", pc_nb[2], res[2], knn[2], "\n")
  ident2 <- fullsample_idents %>%
    dplyr::filter(pc == pc_nb[2], resolution == res[2], k_param == knn[2])  %>%
    pull(original_ident_full) %>%
    `[[`(1)
  seuratobject <- AddMetaData(seuratobject, metadata = ident2, col.name = "set2")
  
  # Plot3
  cat("Set3:", pc_nb[3], res[3], knn[3], "\n")
  ident3 <- fullsample_idents %>%
    dplyr::filter(pc == pc_nb[3], resolution == res[3], k_param == knn[3])  %>%
    pull(original_ident_full) %>%
    `[[`(1)
  seuratobject <- AddMetaData(seuratobject, metadata = ident3, col.name = "set3")
  
  # Combine plots
  p1 <- DimPlot(seuratobject, reduction = "umap", label = TRUE, group.by = "set1", repel = TRUE) +
    ggtitle(paste0("PC=", pc_nb[1], ", resolution=", res[1], ", k.param=", knn[1])) #+ NoLegend()
  p2 <- DimPlot(seuratobject, reduction = "umap", label = TRUE, group.by = "set2", repel = TRUE) +
    ggtitle(paste0("PC=", pc_nb[2], ", resolution=", res[2], ", k.param=", knn[2])) #+ NoLegend()
  p3 <- DimPlot(seuratobject, reduction = "umap", label = TRUE, group.by = "set3", repel = TRUE) +
    ggtitle(paste0("PC=", pc_nb[3], ", resolution=", res[3], ", k.param=", knn[3])) #+ NoLegend()
  print(p1 | p2 | p3)
}
#___________________________


# Look at some different parameter sets
paramUMAP(seur.harmony, res=c(0.4, 0.7, 1))
paramUMAP(seur.harmony, knn=c(10, 20, 50))
paramUMAP(seur.harmony, res=c(0.4, 0.7, 1), knn=c(50, 20, 10))


## nb of clusters for each different combination of parameter set
fullsample_idents %>%
  mutate(cluster_num = purrr::map_dbl(original_ident_full, ~length(unique(.x)))) # 5 to 15 clusters

```

