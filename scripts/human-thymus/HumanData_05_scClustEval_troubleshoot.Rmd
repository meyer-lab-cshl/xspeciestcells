---
title: "Human data - troubleshoot why we get different clusters on local computer & on scClustEval"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---




## 1. Import

```{r import-librairies, message=FALSE}
# Libraries
library(ggplot2)
library(cowplot)
library(Seurat)
library(SeuratWrappers)
library(harmony)
library(tidyverse)
library(scclusteval)
```

```{r import-data}
# Import data
nkt.seur <- readRDS("../../data/07_scClustEval/input/nkt_object_22-11-10.rds")
nkt.subsampling  <- readRDS("../../data/07_scClustEval/thymic_nkt/gather_subsample.rds")
nkt.fullsample <- readRDS("../../data/07_scClustEval/thymic_nkt/gather_full_sample.rds")

# Take quick peek at the data
# nkt.seur
# nkt.seur@meta.data
DimPlot(nkt.seur)
```


## 2. Define functions

```{r seurat-preprocessing}
#___________________________
# FUNCTION TO PREPROCESS DATA AND GET UMAP ON SEPARATE T CELL LINEAGES
Preprocess <- function(seuratobject, SCTsplit=T, res=0.5, harmony_vars= c("Method", "Batch"), printComputation=F){
  
  # Extract the counts data (from RNA assay) and metadata
  counts <- GetAssayData(object = seuratobject, slot = "counts", assay="RNA")
  metadata <- seuratobject@meta.data
  # Create new seurat object with only the counts and the "cleaned" metadata
  initseurat <- CreateSeuratObject(counts = counts, meta.data = metadata, min.cells=20) # keep only genes expressed in at least 20 cells
  
  cat("Initial seurat object:\n")
  print(initseurat) # this is for sanity check
  
  if(SCTsplit==T){
    cat("\n1-Perform SCTransform on split data\n")
    # Normalize with SCTransform by splitting object (per batch)
    seur.list <- SplitObject(initseurat, split.by = "orig.ident")
    for(i in 1:length(seur.list)){
      cat("...SCTransform on", names(seur.list)[i], "\n")
      seur.list[[i]] <-  SCTransform(seur.list[[i]], vars.to.regress = 'percent.mt', verbose=printComputation, seed.use = 1448145)
    }
    # seur.list <- lapply(X = seur.list, FUN = SCTransform, vars.to.regress="percent.mt", method="glmGamPois") # not working
    seur.SCT <- merge(seur.list[[1]], y = unlist(seur.list[-1], use.names=FALSE), merge.data = TRUE)
    sct.hvg  <- SelectIntegrationFeatures(object.list = seur.list, nfeatures = 3000)
    VariableFeatures(seur.SCT) <- sct.hvg
  }
  
  else if(SCTsplit==F){
    cat("\n1-Perform SCTransform on merged data")
    # Normalize with SCTransform (without splitting object)
    seur.SCT <- SCTransform(initseurat,
                            assay="RNA",
                            new.assay.name="SCT",
                            vars.to.regress = 'percent.mt',
                            seed.use = 1448145,
                            verbose=printComputation)
  }
  
  # Run PCA (don't scale data when using SCTransform)
  cat("\n2-Run PCA pre-integration")
  seur.SCT <- RunPCA(object = seur.SCT,
                     assay = "SCT",
                     npcs = 50,
                     seed.use=42,
                     verbose=printComputation)
  p1 <- DimPlot(seur.SCT, reduction = "pca", group.by = "orig.ident") + ggtitle("PCA pre-integration")
  ElbowPlot(seur.SCT)
  cat("\nSeurat object pre-integration:\n")
  print(seur.SCT)
  
  # Run Harmony for integration
  cat("\n3-Run Harmony\n")
  seur.harmony <- RunHarmony(object = seur.SCT,
                             assay.use = "SCT",
                             reduction = "pca",
                             dims.use = 1:50,
                             max.iter.harmony=30,
                             group.by.vars = harmony_vars,
                             plot_convergence = printComputation)
  cat("\nSeurat object post-integration:\n")
  print(seur.harmony)
  cat("\n4-Run UMAP\n")
  seur.harmony <- RunUMAP(object = seur.harmony, dims = 1:15, assay = "SCT", reduction = "harmony", verbose=printComputation, seed.use=42)
  # seur.harmony <- FindNeighbors(object = seur.harmony, dims = 1:15, assay = "SCT", reduction = "harmony", verbose=printComputation) %>%
  #   FindClusters(resolution = res, verbose=printComputation, random.seed=42)
  
  # Show PCA after integration
  p2 <- DimPlot(seur.harmony, reduction = "harmony", group.by = "orig.ident") + ggtitle("PCA post-integration")
  
  print(p1 | p2)
  
  return(seur.harmony)
}
```

```{r sanity-check}
#___________________________
# FUNCTION TO COMPARE CLUSTERING FROM COMPUTER & FROM SCCLUSTEVAL
sanitycheck <- function(seuratobject, fullsample_idents, pc_nb=15, res=0.7, knn=20){
  cat("Please provide seurat object with already UMAP \n")
  params <- paste0("PC=", pc_nb[1], " | resolution=", res[1], " | k.param=", knn[1])
  cat("Parameters:", params, "\n")
  
  # ++++++
  # Perform clustering on computer
  # print(colnames(seuratobject@meta.data))
  seuratobject <- FindNeighbors(object = seuratobject, dims = 1:pc_nb, k.param=knn, nn.eps=0,
                                #assay = "SCT",
                                reduction = "harmony", verbose=F, force.recalc=T) %>%
    FindClusters(resolution = res, n.start=100, verbose=F) #random.seed=42)
  # cat("\nPost-clustering:\n")
  # print(colnames(seuratobject@meta.data))
  p1 <- DimPlot(seuratobject, reduction = "umap", label = TRUE, group.by="seurat_clusters") + ggtitle("Local computer")
  
  # ++++++
  # Get clusters from scClustEval
  ident <- fullsample_idents %>%
    dplyr::filter(pc == pc_nb, resolution == res, k_param == knn)  %>%
    pull(original_ident_full) %>%
    `[[`(1)
  seuratobject <- AddMetaData(seuratobject, metadata = ident, col.name = "scclusteval_clusters")
  p2 <- DimPlot(seuratobject, reduction = "umap", label = TRUE, group.by = "scclusteval_clusters", repel = TRUE) +
    ggtitle("scClustEval")
  
  # ++++++
  # Combine plots
  title <- ggdraw() + 
    draw_label(params, fontface = 'bold', x = 0, hjust = 0) +
    theme(plot.margin = margin(0, 0, 0, 7)) # add margin on the left of the drawing canvas, so title is aligned with left edge of first plot
  plot_grid(
    title, plot_grid(p1, p2, ncol=2),
    ncol = 1,
    rel_heights = c(0.1, 1) # rel_heights values control vertical title margins
  )
}
```




## 3. Assess problem

```{r problem}
# Preprocess data to have UMAP computed on nkt cells
nkt.sct_merged <- Preprocess(seuratobject = nkt.seur, SCTsplit = F, harmony_vars = c("Sex", "Method"), printComputation = F)
# DimPlot(nkt.sct_merged, group.by="Donor") # sanity check
# ElbowPlot(nkt.sct_merged, ndims=50)


# Look at the clusters obtained on local computer vs on scclusteval
sanitycheck(seuratobject = nkt.sct_merged, fullsample_idents = nkt.fullsample, pc_nb=15, res=0.7, knn=20) # same nb of clusters, but when looking closely, not exactly the same cells are assigned to same clusters
sanitycheck(seuratobject = nkt.sct_merged, fullsample_idents = nkt.fullsample, pc_nb=15, res=0.7, knn=50) # different nb of clusters


# Let's check how many clusters scClustEval assigned for each parameter set
nkt.fullsample %>%
  mutate(cluster_num = purrr::map_dbl(original_ident_full, ~length(unique(.x)))) %>% # 4 to 15 clusters
  arrange(cluster_num)
```




## 4. Use the same function as scClustEval on Elzar (the server)

```{r scclusteval-preprocess}
PreprocessSClustEval <- function(seuratobject, variable.features.n=3000, num.pc=50, resolution=0.5, pc.use=15, k.param=20){
  
  # Extract the counts data (from RNA assay) and metadata
  counts <- GetAssayData(object = seuratobject, slot = "counts", assay="RNA")
  metadata <- seuratobject@meta.data
  # Create new seurat object with only the counts and the "cleaned" metadata
  initseurat <- CreateSeuratObject(counts = counts, meta.data = metadata, min.cells=20) # keep only genes expressed in at least 20 cells
  
  cat("Initial seurat object:\n")
  print(initseurat) # this is for sanity check
  
  # Variables to regress out
  meta.data.colnames<- initseurat@meta.data %>% colnames()
  vars.to.regress<- c("percent.mt","nFeature_RNA")
  # in case the seurat object does not have percent.mito in metadata
  vars.to.regress<- vars.to.regress[vars.to.regress %in% meta.data.colnames]
  
  cat("\n1-Perform SCTransform on merged data")
  # Normalize with SCTransform (without splitting object)
  object <- SCTransform(initseurat,
                        # assay="RNA",
                        # new.assay.name="SCT",
                        vars.to.regress=vars.to.regress,
                        variable.features.n=variable.features.n,
                        # seed.use = 1448145,
                        verbose=F)
  
  # Run PCA (don't scale data when using SCTransform)
  cat("\n2-Run PCA pre-integration with", num.pc, "PCs\n")
  object <- RunPCA(object = object,
                     features = VariableFeatures(object=object),
                     # assay = "SCT",
                     npcs = num.pc,
                     # seed.use=42,
                     verbose=T)
  # p1 <- DimPlot(object, reduction = "pca", group.by = "orig.ident") + ggtitle("PCA pre-integration")
  # ElbowPlot(object)
  
  # add significant pc number to metadata, need to have names same as the cells
  pc.use.meta <- rep(pc.use, length(colnames(object)))
  names(pc.use.meta) <- colnames(object)
  object <- AddMetaData(object = object, metadata = pc.use.meta, col.name = "pc.use")
  
  cat("\nSeurat object pre-integration:\n")
  print(object)
  # cat("\nColumns metadata Seurat object:\n")
  # print(colnames(object@meta.data))
  
  # Run Harmony for integration
  cat("\n3-Run Harmony on", pc.use, "PCs\n")
  object <- RunHarmony(object = object,
                       assay.use = "SCT",
                       reduction = "pca",
                       dims.use = 1:pc.use,
                       max.iter.harmony=30,
                       group.by.vars = c("Sex", "Method"),
                       plot_convergence = F)
  cat("\nSeurat object post-integration:\n")
  print(object)
  
  cat("\n4-Run Clustering on", pc.use, "PCs and", k.param, "neighbors with", resolution, "resolution\n")
  object <- FindNeighbors(object, dims = 1:pc.use, k.param = k.param, nn.eps = 0,
                               verbose = FALSE, reduction = "harmony", force.recalc = TRUE)
  object <- FindClusters(object = object,
                        n.start = 100,
                        resolution = resolution,
                        verbose = FALSE)
  cat("\nNumber of clusters:", length(levels(object@meta.data$seurat_clusters)))

  # Show PCA after integration
  # p2 <- DimPlot(object, reduction = "harmony", group.by = "orig.ident") + ggtitle("PCA post-integration")
  # print(p1 | p2)
  
  return(object)
}
```

```{r sanity-check2}
#___________________________
# FUNCTION TO COMPARE CLUSTERING FROM COMPUTER & FROM SCCLUSTEVAL
comparescClustEval <- function(seuratoplot, seuratlocalscClustEval, fullsample_idents, pc_nb=15, res=0.7, knn=20){
  cat("Please provide seurat object with already UMAP \n")
  params <- paste0("PC=", pc_nb[1], " | resolution=", res[1], " | k.param=", knn[1])
  cat("Parameters:", params, "\n")
  
  # ++++++
  # scClustEval from computer
  seuratoplot <- AddMetaData(seuratoplot, metadata = Idents(seuratlocalscClustEval), col.name = "scclusteval_local")
  p1 <- DimPlot(seuratoplot, reduction = "umap", label = TRUE, group.by="scclusteval_local") + ggtitle("scClustEval local")
  
  # ++++++
  # Get clusters from scClustEval
  ident <- fullsample_idents %>%
    dplyr::filter(pc == pc_nb, resolution == res, k_param == knn)  %>%
    pull(original_ident_full) %>%
    `[[`(1)
  seuratoplot <- AddMetaData(seuratoplot, metadata = ident, col.name = "scclusteval_elzar")
  p2 <- DimPlot(seuratoplot, reduction = "umap", label = TRUE, group.by = "scclusteval_elzar", repel = TRUE) +
    ggtitle("scClustEval Elzar")
  
  # ++++++
  # Combine plots
  title <- ggdraw() + 
    draw_label(params, fontface = 'bold', x = 0, hjust = 0) +
    theme(plot.margin = margin(0, 0, 0, 7)) # add margin on the left of the drawing canvas, so title is aligned with left edge of first plot
  plot_grid(
    title, plot_grid(p1, p2, ncol=2),
    ncol = 1,
    rel_heights = c(0.1, 1) # rel_heights values control vertical title margins
  )
}
```



Now, run the scClustEval preprocess function and compare with the result from Elzar (the server):

```{r run-scClustEval-preprocess}
# Run preprocessing function from scClustEval on local computer
nkt.localscClust <- PreprocessSClustEval(seuratobject=nkt.seur, resolution=0.7, pc.use=15, k.param=50)

# Compare clusters
comparescClustEval(seuratoplot = nkt.sct_merged, seuratlocalscClustEval = nkt.localscClust, fullsample_idents = nkt.fullsample, pc_nb=15, res=0.7, knn=50)
```

Even when using the same function as on Elzar, we don't obtain the same number of clusters...




## 5. Check the RDS object saved on Elzar

```{r import-rds-object}
nkt.k50res07pc15 <- readRDS("~/Projects/20220809_Thymic-iNKT-CrossSpecies/data/07_scClustEval/troubleshooting/full_sample_k_50_resolution_0.7_PC_15.rds")

# Compare clusters
comparescClustEval(seuratoplot = nkt.sct_merged, seuratlocalscClustEval = nkt.k50res07pc15, fullsample_idents = nkt.fullsample, pc_nb=15, res=0.7, knn=50)
```

This time the clusters are the same. So there is no issue with the gather_fullsample.R script. Let's compare the .rds object we got from scClustEval on Elzar vs on local computer

```{r compare-rds-object}
# nkt.k50res07pc15 # object downloaded from Elzar that was generated by scClustEval
# nkt.localscClust # object obtained by running the scClustEval preprocessing function on local computer (on this script)

# There are 3 variable features that are different
table(VariableFeatures(nkt.k50res07pc15) %in% VariableFeatures(nkt.localscClust))
setdiff(VariableFeatures(nkt.k50res07pc15), VariableFeatures(nkt.localscClust))
setdiff(VariableFeatures(nkt.localscClust), VariableFeatures(nkt.k50res07pc15))

# Compare cluster assignments in the two objects
table(Idents(nkt.k50res07pc15), Idents(nkt.localscClust))

# Difference in package versions
sessionInfo()
# Local computer      |    Elzar
# harmony_0.1.0       |  harmony_1.0
# Rcpp_1.0.9          |  Rcpp_1.0.8.3
# purr_0.3.5          |  purr_0.3.4
# readr_2.1.3         |  readr_2.1.2
# SeuratObject_4.1.2  |  SeuratObject_4.1.1
# Seurat_4.2.0        |  Seurat_4.1.1

# Check the raw counts from two objects
identical(GetAssayData(nkt.localscClust, slot="count", assay="RNA"), GetAssayData(nkt.k50res07pc15, slot="count", assay="RNA")) # TRUE
```



